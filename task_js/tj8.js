// Знайти найблільше число поліндром яке утворюється завдяки добутку двох простих пятизначних чисел.

// Решето Аткина

// В 1999 году Аткин и Бернштейн предложили новый метод высеивания составных чисел, получивший название решета Аткина. Он основан на следующей теореме.

// Теорема. Пусть n — натуральное число, которое не делится ни на какой полный квадрат. Тогда
// если n представимо в виде 4k+1, то оно просто тогда и только тогда, когда число натуральных решений уравнения 4x2+y2 = n нечетно.
// если n представимо в виде 6k+1, то оно просто тогда и только тогда, когда число натуральных решений уравнения 3x2+y2 = n нечетно.
// если n представимо в виде 12k-1, то оно просто тогда и только тогда, когда число натуральных решений уравнения 3x2−y2 = n, для которых x > y, нечетно.
// C доказательством можно ознакомиться в [4].

// Из элементарной теории чисел следует, что все простые, большие 3, имеют вид 12k+1 (случай 1), 12k+5 (снова 1), 12k+7 (случай 2) или 12k+11 (случай 3).

// Для инициализации алгоритма заполним решето S нулями. Теперь для каждой пары (x, y), где , инкрементируем значения в ячейках S[4x2+y2], S[3x2+y2], а также, если x > y, то и в S[3x2−y2]. В конце вычислений номера ячеек вида 6k±1, содержащие нечетные числа, — это или простые, или делятся на квадраты простых.

// В качестве заключительного этапа пройдемся по предположительно простым номерам последовательно и вычеркнем кратные их квадратам.

let S=[];
let simple=[];
for(let index=10000; index<100000; index++){
    S[index]=0;
}


for(let x=0; x<=Math.sqrt(99999); x++){
    for(let y=0; y<Math.sqrt(100000); y++){
        S[4*Math.pow(x,2)+Math.pow(y,2)]=1;
        S[3*Math.pow(x,2)+Math.pow(y,2)]=1;
        if(x>y){
            S[3*Math.pow(x,2)-Math.pow(y,2)]=1;
        }
    }
}


for(let k=Math.floor((99999-1)/6); k>=(10000-1)/6; k--){   
    
    if(S[6*k-1]){
        isSim=true;
        for(let i=2;i<Math.sqrt(99999);i++){
            if(!( (6*k-1) % i )){
                isSim=false;
                break;
            }
        }  
        if(isSim){
            simple.push(6*k-1)
        }     
    }
 

    if(S[6*k+1]){
        isSim=true;
        for(let i=2;i<Math.sqrt(99999);i++){
            if(!((6*k+1)%i)){
                isSim=false;
                break;
            }
        }  
        if(isSim){
            simple.push(6*k+1)
        }     
    }
}


console.log(simple);

for(let i=0; i<simple.length; i++){
    for(let j=0; j<simple.length; j++){
        isPol=true;
        numm=''+simple[i]*simple[j];
        for(let n=0; n<Math.floor(numm.length/2); n++){
            if(numm[n]!==numm[numm.length-1-n]){
                isPol=false;
                break;
            }
        }
        if(isPol){
            console.log('Поліндром='+numm+'; прості числа: '+simple[i]+'; '+simple[j]);
            break;
        }

    }
    if(isPol){
        break;
    }
}